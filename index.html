<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é€šç”¨é«˜ç²¾åº¦å›¾ç‰‡æ–‡å­—æœ—è¯»ï¼ˆè‡ªåŠ¨æ–­å¥ç‰ˆï¼‰</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Microsoft YaHei", sans-serif;
    }
    body {
      max-width: 800px;
      margin: 30px auto;
      padding: 0 20px;
      background: #f8f9fa;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 15px rgba(0,0,0,0.05);
      text-align: center;
    }
    h1 {
      color: #2d3748;
      margin-bottom: 30px;
      font-weight: 600;
    }
    .upload-area {
      border: 2px dashed #4299e1;
      border-radius: 8px;
      padding: 50px 20px;
      margin-bottom: 30px;
      transition: all 0.3s;
      cursor: pointer;
    }
    .upload-area:hover {
      border-color: #38b2ac;
      background: #f0f8fb;
    }
    .upload-icon {
      font-size: 48px;
      color: #4299e1;
      margin-bottom: 15px;
    }
    .upload-tip {
      font-size: 16px;
      color: #4a5568;
      margin-bottom: 20px;
    }
    .upload-btn {
      padding: 12px 30px;
      background: #4299e1;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .upload-btn:hover {
      background: #3182ce;
    }
    #file-input {
      display: none;
    }
    .status-text {
      font-size: 16px;
      color: #718096;
      margin: 20px 0;
    }
    .loading {
      color: #4299e1;
      animation: blink 1.5s infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .result-area {
      margin-bottom: 30px;
      text-align: left;
    }
    .result-title {
      font-size: 18px;
      color: #2d3748;
      margin-bottom: 15px;
      font-weight: 600;
    }
    #result-content {
      background: #f7fafc;
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #dee2e6;
      min-height: 100px;
      white-space: pre-line;
      font-size: 15px;
      color: #2d3748;
      line-height: 1.8;
    }
    .btn-group {
      margin-top: 20px;
    }
    .func-btn {
      padding: 12px 30px;
      margin: 0 10px;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
    }
    .read-btn {
      background: #48bb78;
      color: white;
    }
    .read-btn:disabled {
      background: #a3e635;
      cursor: not-allowed;
    }
    .stop-btn {
      background: #e53e3e;
      color: white;
    }
    .stop-btn:disabled {
      background: #fca5a5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>é€šç”¨é«˜ç²¾åº¦å›¾ç‰‡æ–‡å­—æœ—è¯»ï¼ˆè‡ªåŠ¨æ–­å¥ç‰ˆï¼‰</h1>
    <div class="upload-area" id="upload-area">
      <div class="upload-icon">ğŸ“·</div>
      <p class="upload-tip">ç‚¹å‡»é€‰æ‹©å›¾ç‰‡ï¼Œæˆ–ç›´æ¥æ‹–æ”¾å›¾ç‰‡åˆ°æ­¤å¤„</p>
      <input type="file" id="file-input" accept="image/*">
      <button class="upload-btn" id="select-img-btn">é€‰æ‹©å›¾ç‰‡</button>
    </div>
    <div class="status-text" id="status-text">è¯·ä¸Šä¼ å›¾ç‰‡å¼€å§‹è¯†åˆ«</div>
    <div class="result-area">
      <h3 class="result-title">è¯†åˆ«ç»“æœï¼ˆè‡ªåŠ¨æ–­å¥ï¼‰ï¼š</h3>
      <div id="result-content">ç­‰å¾…è¯†åˆ«...</div>
    </div>
    <div class="btn-group">
      <button class="func-btn read-btn" id="read-btn" disabled>æœ—è¯»æ–‡å­—</button>
      <button class="func-btn stop-btn" id="stop-btn" disabled>åœæ­¢æœ—è¯»</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
  <script>
    class AutoPunctuationReader {
      constructor() {
        // DOMå…ƒç´ ç»‘å®š
        this.fileInput = document.getElementById('file-input');
        this.selectImgBtn = document.getElementById('select-img-btn');
        this.uploadArea = document.getElementById('upload-area');
        this.statusText = document.getElementById('status-text');
        this.resultContent = document.getElementById('result-content');
        this.readBtn = document.getElementById('read-btn');
        this.stopBtn = document.getElementById('stop-btn');

        // çŠ¶æ€å˜é‡
        this.speechSynthesis = window.speechSynthesis;
        this.recognizedText = '';

        // é€šç”¨å­—å½¢æ··æ·†çº é”™å­—å…¸ï¼ˆåŸºäºä¸­æ–‡å¸¸è§è¯¯è¯†åˆ«è§„åˆ™ï¼‰
        this.universalErrorMap = {
          "ä¾¿": "ä½¿", "æŒ": "æ", "æƒ§": "æƒ³", "è°…": "è¯»", "æ•·": "æ•´",
          "åµ": "å³", "å¸": "å¯", "è´¼": "è§ˆ", "æ¸": "æ®", "æ¸¡": "æ¸²",
          "åƒ³": "ä¿®", "è‘›": "å–„", "æŠ€": "æŒ", "è¯": "é€€", "è¿™": "è¿¹",
          "é”€": "é”®", "ç½©": "ç½²", "åˆ‡": "ä»“", "é”°": "é“¾", "æˆ": "æ¥",
          "ç»œ": "ç»™", "å€Ÿ": "ä½¿", "æ¸…": "æµ", "è´¢": "æ—¶", "é¢„": "è§ˆ",
          "çœ‹": "æŸ¥", "é—´": "ç‰ˆ"
        };

        // è‡ªåŠ¨æ–­å¥é…ç½®ï¼ˆä¸­æ–‡è¯­æ³•è§„åˆ™ï¼‰
        this.punctuationRules = {
          // å¼ºåˆ¶æ–­å¥æ ‡ç‚¹ï¼ˆåæ¥æ¢è¡Œï¼‰
          forceBreak: /([ã€‚ï¼ï¼Ÿ])/g,
          // é€»è¾‘æ–­å¥æ ‡ç‚¹ï¼ˆåæ¥ç©ºæ ¼ï¼Œä¸æ¢è¡Œï¼‰
          logicBreak: /([ï¼›ï¼šï¼Œ])/g,
          // æ®µè½æ‹†åˆ†å…³é”®è¯ï¼ˆå‰æ¥æ¢è¡Œï¼‰
          paragraphKeywords: ['è‡ªç„¶è¯­è¨€æ–¹å¼è¡¨è¿°', 'å®æ—¶é¢„è§ˆæ•ˆæœ', 'å±€éƒ¨å®šä½ä¿®æ”¹', 'ä¸€é”®éƒ¨ç½²åˆ†äº«', 'åŠŸèƒ½', 'ç‰¹æ€§', 'ä¼˜åŠ¿', 'è¯´æ˜'],
          // é¿å…æ–­å¥çš„å›ºå®šæ­é…
          noBreakPairs: ['æ ¹æ®', 'åŸºäº', 'é€šè¿‡', 'ä½¿ç”¨', 'æ— éœ€', 'æ”¯æŒ', 'å¯ç›´æ¥', 'è‡ªåŠ¨', 'å®æ—¶', 'å±€éƒ¨', 'ä¸€é”®', 'ç®€åŒ–']
        };

        // åˆå§‹åŒ–äº‹ä»¶
        this.initEvents();
      }

      initEvents() {
        // æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        this.selectImgBtn.addEventListener('click', () => this.fileInput.click());
        this.fileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) this.handleUpload(file);
        });

        // æ‹–æ”¾äº‹ä»¶
        this.uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          this.uploadArea.style.borderColor = '#38b2ac';
        });
        this.uploadArea.addEventListener('dragleave', () => {
          this.uploadArea.style.borderColor = '#4299e1';
        });
        this.uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          this.uploadArea.style.borderColor = '#4299e1';
          const file = e.dataTransfer.files[0];
          if (file) this.handleUpload(file);
        });

        // æœ—è¯»/åœæ­¢æŒ‰é’®
        this.readBtn.addEventListener('click', () => this.speak());
        this.stopBtn.addEventListener('click', () => this.stopSpeak());
      }

      handleUpload(file) {
        // å›¾ç‰‡æ ¼å¼éªŒè¯
        const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp'];
        if (!validTypes.includes(file.type)) {
          alert('è¯·é€‰æ‹©å›¾ç‰‡æ ¼å¼æ–‡ä»¶ï¼');
          this.updateStatus('æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ', 'red');
          return;
        }

        // ä¸Šä¼ åå®æ—¶åé¦ˆ
        this.updateStatus('æ­£åœ¨é¢„å¤„ç†å›¾ç‰‡ï¼ˆå«è‡ªåŠ¨æ–­å¥ä¼˜åŒ–ï¼‰...', '#4299e1');
        this.resultContent.textContent = 'è¯†åˆ«ä¸­...';
        this.readBtn.disabled = true;

        // å¼€å§‹è¯†åˆ«
        this.recognize(file);
      }

      // é€šç”¨å›¾ç‰‡é¢„å¤„ç†ï¼ˆä¿æŒé«˜ç²¾åº¦åŸºç¡€ï¼‰
      async preprocess(file) {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = 'Anonymous';
          img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // 1. è‡ªé€‚åº”æ”¾å¤§
            const scale = img.width < 800 || img.height < 600 ? 2 : 1.2;
            canvas.width = Math.floor(img.width * scale);
            canvas.height = Math.floor(img.height * scale);

            // 2. åŒçº¿æ€§æ’å€¼ç»˜åˆ¶
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // 3. ç°åº¦åŒ–
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
              data[i] = data[i + 1] = data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);

            // 4. è‡ªé€‚åº”äºŒå€¼åŒ–
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;
            let sum = 0, count = 0;
            for (let i = 0; i < data.length; i += 4) {
              sum += data[i];
              count++;
            }
            const avgGray = sum / count;
            const threshold = avgGray < 120 ? avgGray + 30 : avgGray - 20;
            for (let i = 0; i < data.length; i += 4) {
              const gray = data[i];
              const binary = gray > threshold ? 255 : 0;
              data[i] = data[i + 1] = data[i + 2] = binary;
            }
            ctx.putImageData(imageData, 0, 0);

            // 5. è½»åº¦é™å™ª
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            for (let y = 1; y < height - 1; y++) {
              for (let x = 1; x < width - 1; x++) {
                const idx = (y * width + x) * 4;
                const current = data[idx];
                const neighbors = [
                  data[((y-1)*width + (x-1)) * 4],
                  data[((y-1)*width + x) * 4],
                  data[((y-1)*width + (x+1)) * 4],
                  data[(y*width + (x-1)) * 4],
                  data[(y*width + (x+1)) * 4],
                  data[((y+1)*width + (x-1)) * 4],
                  data[((y+1)*width + x) * 4],
                  data[((y+1)*width + (x+1)) * 4],
                ].filter(p => p === 0).length;
                if (current === 0 && neighbors < 2) {
                  data[idx] = data[idx + 1] = data[idx + 2] = 255;
                }
              }
            }
            ctx.putImageData(imageData, 0, 0);

            resolve(canvas.toDataURL('image/png'));
          };
          img.src = URL.createObjectURL(file);
        });
      }

      // æ ¸å¿ƒè¯†åˆ«é€»è¾‘
      async recognize(file) {
        try {
          this.updateStatus('åŠ è½½é€šç”¨é«˜ç²¾åº¦è¯†åˆ«æ¨¡å‹...', '#4299e1');
          
          // é€šç”¨å›¾ç‰‡é¢„å¤„ç†
          const processedImg = await this.preprocess(file);
          
          // Tesseracté€šç”¨ä¼˜åŒ–å‚æ•°
          const result = await Tesseract.recognize(
            processedImg,
            'chi_sim_vert+chi_sim+eng',
            {
              logger: (m) => {
                if (m.status === 'recognizing text') {
                  this.updateStatus(`è¯†åˆ«ä¸­ï¼š${Math.round(m.progress*100)}%`, '#4299e1');
                }
              },
              tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
              tessedit_pageseg_mode: Tesseract.PSM.AUTO,
              load_system_dawg: 1,
              load_freq_dawg: 1,
              load_unambig_dawg: 1,
              load_punc_dawg: 1,
              load_number_dawg: 1,
              tessedit_char_blacklist: '(){}[]|@#$%^&*_+-=\\/<>?~`',
              preserve_interword_spaces: 1,
              tessedit_do_invert: 0,
              classify_bln_numeric_mode: 1,
            }
          );

          // é€šç”¨æ–‡æœ¬åå¤„ç† + æ–°å¢è‡ªåŠ¨æ–­å¥
          this.recognizedText = this.universalPostProcess(result.data.text);

          // ç»“æœåé¦ˆ
          this.updateStatus('é€šç”¨é«˜ç²¾åº¦è¯†åˆ«å®Œæˆï¼ˆå·²è‡ªåŠ¨æ–­å¥ï¼‰', '#48bb78');
          this.resultContent.textContent = this.recognizedText || 'æœªè¯†åˆ«åˆ°æœ‰æ•ˆæ–‡å­—';
          this.readBtn.disabled = !this.recognizedText;
        } catch (err) {
          this.updateStatus(`è¯†åˆ«å¤±è´¥ï¼š${err.message}`, 'red');
          this.resultContent.textContent = 'è¯†åˆ«å‡ºé”™ï¼Œè¯·é‡è¯•ï¼ˆå»ºè®®ä½¿ç”¨æ¸…æ™°å›¾ç‰‡ï¼‰';
        }
      }

      // é€šç”¨æ–‡æœ¬åå¤„ç†ï¼ˆå«è‡ªåŠ¨æ–­å¥æ ¸å¿ƒé€»è¾‘ï¼‰
      universalPostProcess(text) {
        if (!text) return '';

        // æ­¥éª¤1ï¼šå»é™¤å¤šä½™ç©ºæ ¼å’Œæ¢è¡Œ
        let processed = text.replace(/\s+/g, ' ').trim();

        // æ­¥éª¤2ï¼šé€šç”¨å­—å½¢æ··æ·†çº é”™
        Object.keys(this.universalErrorMap).forEach(key => {
          const reg = new RegExp(key, 'g');
          processed = processed.replace(reg, this.universalErrorMap[key]);
        });

        // æ­¥éª¤3ï¼šè‡ªåŠ¨æ–­å¥ï¼ˆæ ¸å¿ƒæ–°å¢ï¼‰
        processed = this.autoPunctuate(processed);

        // æ­¥éª¤4ï¼šå»é™¤æ— æ•ˆå­—ç¬¦
        processed = processed.replace(/[^\u4e00-\u9fa5a-zA-Z0-9ï¼Œã€‚ï¼›ï¼ï¼Ÿï¼šï¼ˆï¼‰ã€ã€‘ã€\s]/g, '');

        // æ­¥éª¤5ï¼šæ•´ç†ç©ºè¡Œï¼ˆé¿å…è¿ç»­æ¢è¡Œï¼‰
        processed = processed.replace(/\n+/g, '\n').trim();

        return processed;
      }

      // æ–°å¢ï¼šè‡ªåŠ¨æ–­å¥æ ¸å¿ƒæ–¹æ³•ï¼ˆåŸºäºä¸­æ–‡è¯­æ³•è§„åˆ™ï¼‰
      autoPunctuate(text) {
        let result = text;

        // è§„åˆ™1ï¼šæ®µè½æ‹†åˆ†ï¼ˆå…³é”®è¯å‰åŠ æ¢è¡Œï¼‰
        this.punctuationRules.paragraphKeywords.forEach(keyword => {
          const reg = new RegExp(`(${keyword})`, 'g');
          // é¿å…å¼€å¤´æ¢è¡Œ
          if (result.startsWith(keyword)) {
            result = result.replace(new RegExp(`^${keyword}`), keyword);
          } else {
            result = result.replace(reg, `\n$1`);
          }
        });

        // è§„åˆ™2ï¼šå¼ºåˆ¶æ–­å¥ï¼ˆã€‚ï¼ï¼ŸååŠ æ¢è¡Œï¼‰
        result = result.replace(this.punctuationRules.forceBreak, '$1\n');

        // è§„åˆ™3ï¼šé€»è¾‘æ–­å¥ï¼ˆï¼›ï¼šï¼ŒååŠ ç©ºæ ¼ï¼‰
        result = result.replace(this.punctuationRules.logicBreak, '$1 ');

        // è§„åˆ™4ï¼šä¿®å¤è¿‡åº¦æ–­å¥ï¼ˆä¿ç•™å›ºå®šæ­é…ï¼‰
        this.punctuationRules.noBreakPairs.forEach(pair => {
          // ä¿®å¤â€œæ­é… è¯â€â†’â€œæ­é…è¯â€ï¼ˆé¿å…ç©ºæ ¼æ‹†åˆ†ï¼‰
          const reg = new RegExp(`(${pair})\\s+`, 'g');
          result = result.replace(reg, '$1');
        });

        // è§„åˆ™5ï¼šå¥é¦–ç©ºæ ¼å»é™¤
        result = result.replace(/^\s+/gm, '');

        return result;
      }

      // çŠ¶æ€æ›´æ–°è¾…åŠ©æ–¹æ³•
      updateStatus(text, color = '#718096') {
        this.statusText.textContent = text;
        this.statusText.style.color = color;
        if (text.includes('è¯†åˆ«ä¸­') || text.includes('å¤„ç†ä¸­') || text.includes('åŠ è½½ä¸­')) {
          this.statusText.classList.add('loading');
        } else {
          this.statusText.classList.remove('loading');
        }
      }

      // æœ—è¯»åŠŸèƒ½
      speak() {
        if (!this.recognizedText) return;
        this.stopSpeak();
        const utterance = new SpeechSynthesisUtterance(this.recognizedText);
        utterance.lang = 'zh-CN';
        utterance.rate = 0.85;
        utterance.onend = () => {
          this.readBtn.disabled = false;
          this.stopBtn.disabled = true;
        };
        this.speechSynthesis.speak(utterance);
        this.readBtn.disabled = true;
        this.stopBtn.disabled = false;
      }

      // åœæ­¢æœ—è¯»
      stopSpeak() {
        if (this.speechSynthesis?.speaking) {
          this.speechSynthesis.cancel();
          this.readBtn.disabled = false;
          this.stopBtn.disabled = true;
        }
      }
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', () => {
      new AutoPunctuationReader();
    });
  </script>
</body>
</html>